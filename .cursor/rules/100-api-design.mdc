---
description: "REST and GraphQL API design patterns and best practices"
globs: ["**/api/**/*", "**/routes/**/*", "**/endpoints/**/*", "**/controllers/**/*", "**/graphql/**/*", "**/resolvers/**/*"]
---

# API Design Patterns

## REST URL Structure

```
GET    /api/v1/users              # List
GET    /api/v1/users/:id          # Get one
POST   /api/v1/users              # Create
PUT    /api/v1/users/:id          # Update (full)
PATCH  /api/v1/users/:id          # Update (partial)
DELETE /api/v1/users/:id          # Delete
GET    /api/v1/users/:id/posts    # Nested resource
```

## HTTP Status Codes

| Code | When to Use |
|------|-------------|
| 200 | Success (GET, PUT, PATCH) |
| 201 | Resource created (POST) |
| 204 | Success, no body (DELETE) |
| 400 | Invalid input |
| 401 | Not authenticated |
| 403 | Not authorized |
| 404 | Not found |
| 422 | Validation failed |
| 429 | Rate limit exceeded |
| 500 | Server error |

## Response Format

```json
{
  "data": { "id": "123", "name": "Example" },
  "meta": { "timestamp": "2025-01-01T00:00:00Z" }
}
```

## Error Format

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input",
    "details": [{ "field": "email", "message": "Invalid format" }]
  }
}
```

## REST Rules

- Use plural nouns for collections (`/users` not `/user`)
- No verbs in URLs (`/users` not `/getUsers`)
- Max 2 levels of nesting
- Always validate inputs with schemas (Zod, Pydantic)
- Implement pagination for lists
- Version your APIs (`/api/v1/`)

## GraphQL Design

### Schema Structure
```graphql
type Query {
  user(id: ID!): User
  users(first: Int, after: String): UserConnection!
}

type Mutation {
  createUser(input: CreateUserInput!): CreateUserPayload!
}

type User {
  id: ID!
  email: String!
  profile: Profile
}
```

### Resolver Pattern
```typescript
const resolvers = {
  Query: {
    user: (_, { id }, ctx) => ctx.dataSources.users.getById(id),
  },
  User: {
    profile: (parent, _, ctx) => ctx.dataSources.profiles.getByUserId(parent.id),
  },
};
```

### GraphQL Error Handling
```typescript
throw new UserInputError('Invalid email', {
  invalidArgs: ['email'],
});
```

### Relay-Style Pagination
```graphql
type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

type UserEdge {
  cursor: String!
  node: User!
}
```

## GraphQL vs REST - When to Use

| Use Case | Prefer |
|----------|--------|
| Simple CRUD | REST |
| Complex nested data | GraphQL |
| Mobile (bandwidth) | GraphQL |
| Public API | REST |
| Microservices | REST |
| Single frontend team | GraphQL |
